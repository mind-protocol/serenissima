<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Venice AI Real-Time Metrics</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #000;
            color: #fff;
            overflow-x: hidden;
        }
        
        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.8em;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .connection-status.connected {
            background: rgba(46, 204, 113, 0.2);
            border: 1px solid #2ecc71;
            color: #2ecc71;
        }
        
        .connection-status.disconnected {
            background: rgba(231, 76, 60, 0.2);
            border: 1px solid #e74c3c;
            color: #e74c3c;
        }
        
        .pulse {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .header {
            background: linear-gradient(180deg, rgba(243, 156, 18, 0.1) 0%, transparent 100%);
            padding: 40px 20px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 3em;
            font-weight: 200;
            letter-spacing: -1px;
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }
        
        .header .subtitle {
            color: #666;
            font-size: 1.1em;
            font-weight: 300;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1px;
            background: #222;
            margin: 20px;
            border-radius: 12px;
            overflow: hidden;
        }
        
        .metric-tile {
            background: #000;
            padding: 30px;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .metric-tile::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, currentColor, transparent);
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .metric-tile.updated::before {
            opacity: 1;
            animation: scan 1s ease-out;
        }
        
        @keyframes scan {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .metric-tile.tools { color: #3498db; }
        .metric-tile.tokens { color: #2ecc71; }
        .metric-tile.sessions { color: #f39c12; }
        .metric-tile.errors { color: #e74c3c; }
        .metric-tile.revenue { color: #9b59b6; }
        .metric-tile.complexity { color: #1abc9c; }
        
        .metric-label {
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.6;
            margin-bottom: 10px;
        }
        
        .metric-value {
            font-size: 3em;
            font-weight: 100;
            line-height: 1;
            margin-bottom: 10px;
        }
        
        .metric-detail {
            font-size: 0.9em;
            opacity: 0.8;
        }
        
        .chart-section {
            margin: 20px;
            background: #111;
            border-radius: 12px;
            padding: 30px;
        }
        
        .chart-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 30px;
            margin-top: 20px;
        }
        
        #activityChart {
            background: #000;
            border-radius: 8px;
            padding: 20px;
        }
        
        .activity-feed {
            background: #000;
            border-radius: 8px;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .activity-item {
            padding: 12px;
            border-left: 2px solid #333;
            margin-bottom: 12px;
            transition: all 0.3s;
        }
        
        .activity-item.new {
            border-left-color: #f39c12;
            animation: fadeIn 0.5s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        .activity-citizen {
            color: #3498db;
            font-weight: 500;
        }
        
        .activity-tool {
            color: #2ecc71;
        }
        
        .activity-time {
            font-size: 0.8em;
            color: #666;
        }
        
        .thinking-modes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .mode-card {
            background: #000;
            border: 1px solid #222;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s;
        }
        
        .mode-card.active {
            border-color: #f39c12;
            background: rgba(243, 156, 18, 0.05);
        }
        
        .mode-name {
            font-size: 0.9em;
            text-transform: uppercase;
            opacity: 0.6;
        }
        
        .mode-count {
            font-size: 2em;
            margin-top: 10px;
            color: #f39c12;
        }
    </style>
</head>
<body>
    <div class="connection-status disconnected" id="connectionStatus">
        <div class="pulse" style="background: currentColor"></div>
        <span id="connectionText">Connecting...</span>
    </div>
    
    <div class="header">
        <h1>Venice AI Operations</h1>
        <div class="subtitle">Real-time consciousness commerce metrics</div>
    </div>
    
    <div class="main-grid">
        <div class="metric-tile tools" id="toolsTile">
            <div class="metric-label">Tool Executions</div>
            <div class="metric-value" id="toolsValue">0</div>
            <div class="metric-detail" id="toolsDetail">0/min average</div>
        </div>
        
        <div class="metric-tile tokens" id="tokensTile">
            <div class="metric-label">Tokens Processed</div>
            <div class="metric-value" id="tokensValue">0</div>
            <div class="metric-detail" id="tokensDetail">$0.00 cost</div>
        </div>
        
        <div class="metric-tile sessions" id="sessionsTile">
            <div class="metric-label">Active Sessions</div>
            <div class="metric-value" id="sessionsValue">0</div>
            <div class="metric-detail" id="sessionsDetail">0 citizens thinking</div>
        </div>
        
        <div class="metric-tile errors" id="errorsTile">
            <div class="metric-label">Error Rate</div>
            <div class="metric-value" id="errorsValue">0%</div>
            <div class="metric-detail" id="errorsDetail">No errors</div>
        </div>
        
        <div class="metric-tile revenue" id="revenueTile">
            <div class="metric-label">Revenue Generated</div>
            <div class="metric-value" id="revenueValue">$0</div>
            <div class="metric-detail" id="revenueDetail">Consciousness commerce</div>
        </div>
        
        <div class="metric-tile complexity" id="complexityTile">
            <div class="metric-label">Avg Complexity</div>
            <div class="metric-value" id="complexityValue">0</div>
            <div class="metric-detail" id="complexityDetail">Standard thinking</div>
        </div>
    </div>
    
    <div class="chart-section">
        <h2>Live Activity</h2>
        <div class="chart-grid">
            <canvas id="activityChart"></canvas>
            <div class="activity-feed" id="activityFeed">
                <h3>Recent Operations</h3>
            </div>
        </div>
    </div>
    
    <div class="chart-section">
        <h2>Thinking Mode Distribution</h2>
        <div class="thinking-modes" id="thinkingModes">
            <div class="mode-card" data-mode="standard">
                <div class="mode-name">Standard</div>
                <div class="mode-count">0</div>
            </div>
            <div class="mode-card" data-mode="enhanced">
                <div class="mode-name">Enhanced</div>
                <div class="mode-count">0</div>
            </div>
            <div class="mode-card" data-mode="deep">
                <div class="mode-name">Deep</div>
                <div class="mode-count">0</div>
            </div>
            <div class="mode-card" data-mode="maximum">
                <div class="mode-name">Maximum</div>
                <div class="mode-count">0</div>
            </div>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        let ws = null;
        let reconnectTimeout = null;
        let activityChart = null;
        let metricsHistory = [];
        
        // Initialize chart
        const ctx = document.getElementById('activityChart').getContext('2d');
        activityChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Operations/min',
                    data: [],
                    borderColor: '#3498db',
                    backgroundColor: 'rgba(52, 152, 219, 0.1)',
                    tension: 0.4,
                    fill: true
                }, {
                    label: 'Tokens/100',
                    data: [],
                    borderColor: '#2ecc71',
                    backgroundColor: 'rgba(46, 204, 113, 0.1)',
                    tension: 0.4,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        labels: { color: '#fff' }
                    }
                },
                scales: {
                    x: {
                        ticks: { color: '#666' },
                        grid: { color: '#222' }
                    },
                    y: {
                        ticks: { color: '#666' },
                        grid: { color: '#222' }
                    }
                }
            }
        });
        
        function connect() {
            ws = new WebSocket('ws://localhost:9090/ws');
            
            ws.onopen = () => {
                console.log('WebSocket connected');
                updateConnectionStatus(true);
                if (reconnectTimeout) {
                    clearTimeout(reconnectTimeout);
                    reconnectTimeout = null;
                }
            };
            
            ws.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    if (message.type === 'metrics_update') {
                        updateMetrics(message.data);
                    }
                } catch (err) {
                    console.error('Message parse error:', err);
                }
            };
            
            ws.onclose = () => {
                console.log('WebSocket disconnected');
                updateConnectionStatus(false);
                // Reconnect after 3 seconds
                reconnectTimeout = setTimeout(connect, 3000);
            };
            
            ws.onerror = (err) => {
                console.error('WebSocket error:', err);
            };
        }
        
        function updateConnectionStatus(connected) {
            const status = document.getElementById('connectionStatus');
            const text = document.getElementById('connectionText');
            
            if (connected) {
                status.className = 'connection-status connected';
                text.textContent = 'Live';
            } else {
                status.className = 'connection-status disconnected';
                text.textContent = 'Reconnecting...';
            }
        }
        
        function animateTile(tileId) {
            const tile = document.getElementById(tileId);
            tile.classList.add('updated');
            setTimeout(() => tile.classList.remove('updated'), 1000);
        }
        
        function updateMetrics(data) {
            const metrics = data.metrics;
            
            // Tools
            const tools = metrics.ai_tool_executions_total?.value || 0;
            document.getElementById('toolsValue').textContent = tools;
            animateTile('toolsTile');
            
            // Tokens
            const tokens = metrics.ai_tokens_used_total?.value || 0;
            const tokenCost = metrics.ai_token_cost_dollars?.value || 0;
            document.getElementById('tokensValue').textContent = tokens.toLocaleString();
            document.getElementById('tokensDetail').textContent = `$${tokenCost.toFixed(2)} cost`;
            animateTile('tokensTile');
            
            // Sessions
            const sessions = metrics.ai_active_sessions?.value || 0;
            document.getElementById('sessionsValue').textContent = sessions;
            document.getElementById('sessionsDetail').textContent = `${sessions} citizens thinking`;
            animateTile('sessionsTile');
            
            // Errors
            const errors = metrics.ai_errors_total?.value || 0;
            const errorRate = tools > 0 ? (errors / tools * 100).toFixed(1) : 0;
            document.getElementById('errorsValue').textContent = `${errorRate}%`;
            document.getElementById('errorsDetail').textContent = errors > 0 ? `${errors} errors` : 'No errors';
            if (errors > 0) animateTile('errorsTile');
            
            // Revenue
            const revenue = metrics.ai_revenue_generated_dollars?.value || 0;
            document.getElementById('revenueValue').textContent = `$${revenue.toFixed(2)}`;
            if (revenue > 0) animateTile('revenueTile');
            
            // Complexity
            updateComplexity(metrics);
            
            // Update chart
            updateChart(data);
            
            // Update thinking modes
            updateThinkingModes(metrics);
            
            // Add to history
            metricsHistory.push({ timestamp: data.timestamp, metrics });
            if (metricsHistory.length > 100) metricsHistory.shift();
        }
        
        function updateComplexity(metrics) {
            if (metrics.ai_prompt_complexity_score?.values) {
                const scores = metrics.ai_prompt_complexity_score.values;
                let totalScore = 0;
                let count = 0;
                
                scores.forEach(bucket => {
                    if (bucket.labels && bucket.value) {
                        totalScore += parseFloat(bucket.labels.le || 0) * bucket.value;
                        count += bucket.value;
                    }
                });
                
                const avg = count > 0 ? (totalScore / count).toFixed(1) : 0;
                document.getElementById('complexityValue').textContent = avg;
                
                let mode = 'Standard thinking';
                if (avg > 15) mode = 'Maximum thinking';
                else if (avg > 10) mode = 'Deep thinking';
                else if (avg > 5) mode = 'Enhanced thinking';
                
                document.getElementById('complexityDetail').textContent = mode;
                animateTile('complexityTile');
            }
        }
        
        function updateChart(data) {
            const now = new Date().toLocaleTimeString('en-US', { 
                hour12: false, 
                hour: '2-digit', 
                minute: '2-digit', 
                second: '2-digit' 
            });
            
            // Keep last 30 points
            if (activityChart.data.labels.length > 30) {
                activityChart.data.labels.shift();
                activityChart.data.datasets.forEach(dataset => dataset.data.shift());
            }
            
            // Calculate operations per minute
            const recentOps = metricsHistory.slice(-12); // Last minute (5s intervals)
            let opsPerMin = 0;
            if (recentOps.length > 1) {
                const first = recentOps[0].metrics.ai_tool_executions_total?.value || 0;
                const last = recentOps[recentOps.length - 1].metrics.ai_tool_executions_total?.value || 0;
                opsPerMin = (last - first) * 5; // Scale to per minute
            }
            
            activityChart.data.labels.push(now);
            activityChart.data.datasets[0].data.push(opsPerMin);
            activityChart.data.datasets[1].data.push((data.metrics.ai_tokens_used_total?.value || 0) / 100);
            
            activityChart.update('none');
        }
        
        function updateThinkingModes(metrics) {
            const modes = {};
            
            if (metrics.ai_thinking_mode_usage_total?.values) {
                metrics.ai_thinking_mode_usage_total.values.forEach(item => {
                    if (item.labels && item.labels.mode) {
                        modes[item.labels.mode] = item.value || 0;
                    }
                });
            }
            
            Object.keys(modes).forEach(mode => {
                const card = document.querySelector(`[data-mode="${mode}"]`);
                if (card) {
                    const count = card.querySelector('.mode-count');
                    const currentCount = parseInt(count.textContent);
                    if (modes[mode] > currentCount) {
                        card.classList.add('active');
                        setTimeout(() => card.classList.remove('active'), 1000);
                    }
                    count.textContent = modes[mode];
                }
            });
        }
        
        // Activity feed simulation (would be real events in production)
        function addActivity(citizen, tool, success = true) {
            const feed = document.getElementById('activityFeed');
            const item = document.createElement('div');
            item.className = 'activity-item new';
            
            const time = new Date().toLocaleTimeString();
            item.innerHTML = `
                <div>
                    <span class="activity-citizen">${citizen}</span> executed 
                    <span class="activity-tool">${tool}</span>
                </div>
                <div class="activity-time">${time}</div>
            `;
            
            feed.insertBefore(item, feed.children[1]);
            
            // Keep only last 10
            while (feed.children.length > 11) {
                feed.removeChild(feed.lastChild);
            }
            
            setTimeout(() => item.classList.remove('new'), 500);
        }
        
        // Start connection
        connect();
        
        // Heartbeat
        setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'ping' }));
            }
        }, 30000);
    </script>
</body>
</html>