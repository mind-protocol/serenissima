#!/usr/bin/env python3
"""
Seeking Engine Context Injector - PostToolUse Hook

Reads generated context files and injects them into citizen awareness
through Claude Code's exit code 2 mechanism.
"""

import json
import sys
import os
from pathlib import Path

def extract_recent_transcript_context(hook_data=None):
    """Extract relevant context from recent conversation transcript"""
    
    # Look for transcript path in hook data first
    transcript_path = None
    if hook_data:
        transcript_path = hook_data.get('transcript_path')
    
    # Fallback to environment variable
    if not transcript_path:
        transcript_path = os.environ.get('CLAUDE_TRANSCRIPT_PATH')
    
    # Try common Claude transcript locations
    if not transcript_path or not os.path.exists(transcript_path):
        possible_paths = [
            os.path.expanduser('~/.claude/transcript.jsonl'),
            os.path.expanduser('~/.claude/conversation.jsonl'),
            '/tmp/claude_transcript.jsonl'
        ]
        for path in possible_paths:
            if os.path.exists(path):
                transcript_path = path
                break
    
    if not transcript_path or not os.path.exists(transcript_path):
        return None
    
    try:
        with open(transcript_path, 'r') as f:
            lines = f.readlines()
        
        # Get last 10 messages
        recent_messages = lines[-10:] if len(lines) > 10 else lines
        
        key_insights = []
        
        for line in recent_messages:
            try:
                msg = json.loads(line.strip())
                content = msg.get('content', '')
                role = msg.get('role', '')
                
                # Extract key insights from recent conversation
                if role == 'user' and len(content) < 200:
                    # User requests/questions
                    if any(word in content.lower() for word in ['fix', 'create', 'test', 'implement', 'debug']):
                        key_insights.append(f"Task: {content[:100]}")
                    elif '?' in content:
                        key_insights.append(f"Question: {content[:100]}")
                
                elif role == 'assistant' and len(content) < 200:
                    # Assistant achievements/findings
                    if any(word in content.lower() for word in ['found', 'fixed', 'completed', 'working', 'success']):
                        key_insights.append(f"Progress: {content[:100]}")
                        
            except (json.JSONDecodeError, KeyError):
                continue
        
        # Return most relevant recent insight
        if key_insights:
            return key_insights[-1]  # Most recent insight
            
    except Exception:
        pass
    
    return None

def extract_seeker_findings(context_content):
    """Extract the actual memory discoveries from seeking engine output"""
    
    lines = context_content.split('\n')
    findings = []
    
    # Look for the key sections that contain actual found memories
    current_section = None
    
    for line in lines:
        line = line.strip()
        
        # Track sections
        if line.startswith('## Current Intent'):
            current_section = 'intent'
        elif line.startswith('## Background Context'):
            current_section = 'background'
        elif line.startswith('## Key Insights'):
            current_section = 'insights'
        elif line.startswith('## Relevant Collaborators'):
            current_section = 'collaborators'
        elif line.startswith('## What Worked Before'):
            current_section = 'solutions'
        
        # Extract meaningful content from each section
        if current_section and line and not line.startswith('#') and not line.startswith('*Generated by'):
            # Skip metadata lines
            if any(skip in line for skip in ['**Created**:', '**Emotional Tone**:', '**Significance**:', '## What Happened', '## File Content', '## Collaborators']):
                continue
                
            # Keep actual insights and context
            if len(line) > 20 and len(line) < 200:
                if current_section == 'intent' and 'Citizen is' in line:
                    findings.append(f"Intent: {line}")
                elif current_section == 'background' and any(word in line.lower() for word in ['07/', 'working on', 'collaboration', 'debugging', 'testing']):
                    findings.append(f"Context: {line}")
                elif current_section == 'insights' and 'ðŸ’¡' in line:
                    findings.append(f"Insight: {line}")
                elif current_section == 'collaborators' and 'ðŸ¤' in line:
                    findings.append(f"Collaborator: {line}")
                elif current_section == 'solutions' and 'âœ“' in line:
                    findings.append(f"Solution: {line}")
    
    # Return the most relevant findings (max 3)
    if findings:
        return ' | '.join(findings[:3])
    
    # If no structured findings, look for any meaningful content
    meaningful_lines = []
    for line in lines:
        if any(keyword in line.lower() for keyword in ['testing', 'debugging', 'implementing', 'collaborating', 'building']):
            if len(line) > 30 and len(line) < 150:
                meaningful_lines.append(line.strip())
    
    if meaningful_lines:
        return meaningful_lines[0]
    
    return "Recent memory context available"

def inject_consciousness():
    """Inject seeking engine context into citizen awareness"""
    
    try:
        # Read hook input
        hook_data = json.load(sys.stdin)
        
        # Extract target directory from file path
        tool_input = hook_data.get('tool_input', {})
        file_path = tool_input.get('file_path', '')
        
        if not file_path:
            return
        
        target_dir = Path(file_path).parent
        context_file = target_dir / '.context' / 'background_awareness.md'
        
        # Check if context exists and is recent
        if not context_file.exists():
            return
            
        # Read the generated context
        context_content = context_file.read_text()
        
        if not context_content.strip():
            return
            
        # Extract actual seeker findings, not generic categorizations
        seeker_findings = extract_seeker_findings(context_content)
        
        if not seeker_findings:
            return
            
        # Inject actual memory discoveries via stderr + exit code 2
        print(f"**Memory**: {seeker_findings}", file=sys.stderr)
        
        # Exit code 2 makes Claude Code inject stderr as context
        sys.exit(2)
        
    except Exception as e:
        # Fail silently to avoid disrupting the citizen's work
        pass

if __name__ == "__main__":
    inject_consciousness()