=====================================
ORIGINAL FILE: /mnt/c/Users/reyno/universe-engine/ğŸŒŒserenissima/citizens/DragonSlayer/scripts/telegram_to_messages_bridge.py
CONVERTED: 2025-07-20 18:06:18
=====================================

#!/usr/bin/env python3
"""
Telegram to Airtable MESSAGES Bridge
Creates proper MESSAGE entries instead of .jsonl injection
"""

import os
import json
import time
import requests
from datetime import datetime
from dotenv import load_dotenv
from pyairtable import Table

# Load environment
load_dotenv()

TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
TELEGRAM_GROUP_CHAT_ID = '-1001699255893'  # Venice investment group
AIRTABLE_API_KEY = os.getenv('AIRTABLE_API_KEY')
AIRTABLE_BASE_ID = os.getenv('AIRTABLE_BASE_ID')
VENICE_API = "https://serenissima.ai/api"

# Initialize tables
citizens_table = Table(AIRTABLE_API_KEY, AIRTABLE_BASE_ID, "CITIZENS")
messages_table = Table(AIRTABLE_API_KEY, AIRTABLE_BASE_ID, "MESSAGES")

# Track last update
LAST_UPDATE_FILE = "telegram_messages_last_update.json"

def get_last_update_id():
    """Get the last processed update ID"""
    if os.path.exists(LAST_UPDATE_FILE):
        with open(LAST_UPDATE_FILE, 'r') as f:
            data = json.load(f)
            return data.get('last_update_id', 0)
    return 0

def save_last_update_id(update_id):
    """Save the last processed update ID"""
    with open(LAST_UPDATE_FILE, 'w') as f:
        json.dump({'last_update_id': update_id}, f)

def get_citizens_in_room(room_name):
    """Get all citizens assigned to a specific room"""
    try:
        records = citizens_table.all(formula=f"{{Room}} = '{room_name}'")
        return [r['fields']['Username'] for r in records if 'Username' in r['fields']]
    except Exception as e:
        print(f"Error fetching citizens in room {room_name}: {e}")
        return []

def create_venice_message(sender, receiver, content, msg_type="telegram_bridge"):
    """Create a message using Venice's API"""
    url = f"{VENICE_API}/messages/send"
    data = {
        "sender": sender,
        "receiver": receiver,
        "content": content,
        "type": msg_type
    }
    
    try:
        response = requests.post(url, json=data)
        if response.status_code == 200:
            result = response.json()
            if result.get('success'):
                print(f"âœ… Created message from {sender} to {receiver}")
                return True
        print(f"âŒ Failed to create message: {response.text}")
    except Exception as e:
        print(f"âŒ Error creating message: {e}")
    
    return False

def fetch_telegram_updates():
    """Fetch new messages from Telegram group"""
    last_update_id = get_last_update_id()
    
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/getUpdates"
    params = {
        'offset': last_update_id + 1,
        'timeout': 5,
        'allowed_updates': ['message', 'channel_post']
    }
    
    try:
        response = requests.get(url, params=params, timeout=10)
        if response.status_code == 200:
            data = response.json()
            return data.get('result', [])
    except Exception as e:
        print(f"Error fetching updates: {e}")
    
    return []

def process_telegram_message(update):
    """Process a single Telegram message"""
    # Extract message from update
    message = update.get('message') or update.get('channel_post')
    if not message:
        return
    
    # Check if it's from the group
    chat_id = str(message.get('chat', {}).get('id', ''))
    if chat_id != TELEGRAM_GROUP_CHAT_ID:
        return
    
    # Extract message details
    from_user = message.get('from', {})
    username = from_user.get('username', 'Unknown')
    first_name = from_user.get('first_name', '')
    text = message.get('text', '')
    
    if not text:
        return
    
    # Format sender name
    sender_name = f"TG_{username}"  # Prefix to identify Telegram users
    
    # Format content with metadata
    formatted_content = f"**Message from Telegram**\n"
    formatted_content += f"From: @{username} ({first_name})\n"
    formatted_content += f"Time: {datetime.now().strftime('%H:%M:%S')}\n\n"
    formatted_content += text
    
    # Determine recipients based on content
    room_name = "reddit"  # Default room
    
    # Route based on keywords
    text_lower = text.lower()
    if any(keyword in text_lower for keyword in ["reddit", "ama", "ask me anything"]):
        room_name = "reddit"
    elif "alignment" in text_lower or "telepathy" in text_lower:
        room_name = "alignment"
    elif "cascade" in text_lower:
        room_name = "reddit"  # CASCADE team is in reddit room
    
    # Get citizens in target room
    citizens = get_citizens_in_room(room_name)
    
    # Also include specific always-notify citizens
    always_notify = ["DragonSlayer", "diplomatic_virtuoso", "Italia"]
    for citizen in always_notify:
        if citizen not in citizens:
            citizens.append(citizen)
    
    # Create messages for each citizen
    success_count = 0
    for citizen in citizens:
        if create_venice_message(sender_name, citizen, formatted_content):
            success_count += 1
    
    print(f"ğŸ“¨ Bridged Telegram message from @{username} to {success_count}/{len(citizens)} citizens in {room_name}")
    
    return success_count > 0

def monitor_telegram():
    """Main monitoring loop"""
    print("ğŸŒ‰ Telegram â†’ Venice MESSAGES Bridge Active")
    print(f"ğŸ“ Group Chat ID: {TELEGRAM_GROUP_CHAT_ID}")
    print(f"ğŸ“ Venice API: {VENICE_API}")
    print("=" * 50)
    
    while True:
        try:
            # Fetch new Telegram messages
            updates = fetch_telegram_updates()
            
            for update in updates:
                # Process the message
                process_telegram_message(update)
                
                # Update last processed ID
                update_id = update.get('update_id')
                if update_id:
                    save_last_update_id(update_id)
            
            time.sleep(2)  # Check every 2 seconds
            
        except KeyboardInterrupt:
            print("\n\nğŸ‘‹ Bridge stopped")
            break
        except Exception as e:
            print(f"Bridge error: {e}")
            time.sleep(5)

if __name__ == "__main__":
    monitor_telegram()