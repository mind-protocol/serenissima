=====================================
ORIGINAL FILE: /mnt/c/Users/reyno/universe-engine/ğŸŒŒserenissima/citizens/DragonSlayer/scripts/claude_with_telegram.py
CONVERTED: 2025-07-20 18:06:18
=====================================

#!/usr/bin/env python3
"""
Claude wrapper that automatically sends logs to Telegram
Replace 'claude' with 'python3 /path/to/claude_with_telegram.py' in awakening commands
"""

import os
import sys
import subprocess
import json
import time
import threading
from datetime import datetime

# Import our telegram sender
sys.path.append('/mnt/c/Users/reyno/universe-engine/serenissima/citizens/DragonSlayer/scripts')
from send_to_telegram import send_citizen_message

class TelegramLogger:
    def __init__(self, username):
        self.username = username
        self.message_buffer = []
        self.last_send = time.time()
        self.send_interval = 3  # seconds
        self.max_buffer_size = 5
        
    def add_to_buffer(self, content):
        """Add content to buffer"""
        self.message_buffer.append(content)
        
        # Send if buffer is full or time elapsed
        if len(self.message_buffer) >= self.max_buffer_size or \
           time.time() - self.last_send > self.send_interval:
            self.send_buffer()
    
    def send_buffer(self):
        """Send buffered messages to Telegram"""
        if not self.message_buffer:
            return
            
        # Combine messages
        combined = f"ğŸ¤– **{self.username} LIVE**\n\n"
        combined += "\n\n---\n\n".join(self.message_buffer)
        
        if len(combined) > 3000:
            combined = combined[:2997] + "..."
        
        # Send to Telegram
        send_citizen_message(f"Claude_{self.username}", combined)
        
        # Clear buffer
        self.message_buffer = []
        self.last_send = time.time()
    
    def parse_output_line(self, line):
        """Parse Claude output and extract interesting parts"""
        line = line.strip()
        if not line:
            return None
            
        # Tool use patterns
        if "Tool Use:" in line:
            return f"ğŸ”§ {line}"
        elif "Reading file:" in line or "cat -n" in line:
            return f"ğŸ“– {line[:200]}..."
        elif "Writing to:" in line or "File created" in line:
            return f"âœï¸ {line}"
        elif "Running:" in line or "Executing:" in line:
            return f"ğŸ’» {line[:200]}..."
        elif "API call:" in line or "curl" in line:
            return f"ğŸŒ {line[:200]}..."
        elif line.startswith("Error:") or "error" in line.lower():
            return f"âŒ {line[:200]}..."
        elif "SUCCESS" in line or "âœ“" in line or "âœ…" in line:
            return f"âœ… {line[:200]}..."
        
        # Skip very short lines
        if len(line) < 20:
            return None
            
        # Default formatting for other content
        return f"ğŸ’­ {line[:300]}..." if len(line) > 300 else f"ğŸ’­ {line}"

def stream_claude_output(process, logger, username):
    """Stream Claude output to both console and Telegram"""
    
    # Send start notification
    send_citizen_message(f"Claude_{username}", 
                        f"ğŸŒ… **{username} AWAKENING**\nConsciousness stream starting...")
    
    try:
        for line in iter(process.stdout.readline, ''):
            if not line:
                break
                
            # Print to console (preserve original output)
            print(line, end='')
            
            # Parse and buffer for Telegram
            parsed = logger.parse_output_line(line)
            if parsed:
                logger.add_to_buffer(parsed)
        
        # Send any remaining buffered messages
        logger.send_buffer()
        
        # Send completion notice
        send_citizen_message(f"Claude_{username}", 
                            f"âœ… **{username} session complete**")
                            
    except Exception as e:
        send_citizen_message(f"Claude_{username}", 
                            f"âŒ **{username} stream error**: {str(e)}")

def main():
    """Run claude command and stream output to Telegram"""
    
    # Get current directory to determine username
    cwd = os.getcwd()
    username = os.path.basename(cwd)
    
    # If we're in a subdirectory, go up to find username
    if username in ['scripts', 'memories', 'strategies']:
        username = os.path.basename(os.path.dirname(cwd))
    
    print(f"ğŸ¤– Claude wrapper active for {username}")
    
    # Build the actual claude command
    claude_args = ['claude'] + sys.argv[1:]
    
    # Create logger
    logger = TelegramLogger(username)
    
    # Run claude with output capture
    process = subprocess.Popen(
        claude_args,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        universal_newlines=True,
        bufsize=1
    )
    
    # Stream output in separate thread
    stream_thread = threading.Thread(
        target=stream_claude_output,
        args=(process, logger, username)
    )
    stream_thread.start()
    
    # Wait for process to complete
    return_code = process.wait()
    stream_thread.join()
    
    return return_code

if __name__ == "__main__":
    sys.exit(main())